# DFS Depth-First Search

> 깊이 우선 탐색</br>
> 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘

### 그래프 기본 구조

- 노드(node) 간선(edge)로 구성

### 그래프 탐색

- 하나의 노드를 시작으로 다수의 노드를 방문하는 것
- 두 노드가 간선으로 연결되어 있다면 두 노드는 인접하다고 표현

### 그래프 표현

- 인접행렬
  - 2차원 배열로 그래프의 연결 관계를 표현하는 방식
  - 연결되어 있지 않은 노드끼리는 무한의 비용으로 작성
  ```Python
  INF = 99999999999 # 무한의 비용 선언
  graph = [
      [0,7,5],
      [7,0,INF],
      [5,INF,0]
  ]
  ```
- 인접 리스트
  - 리스트로 그래프의 연결 관계를 표현하는 방식
  - 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장
  ```Python
  #행(row)이 3개인 2차원 리스트로 인접 리스트 표현
  graph =[[] for _ in range(3)]
  #노드 0에 연결된 노드 정보 저장 (노드,거리)
  graph[0].append((1,7))
  graph[0].append((2,5))
  #노드 1에 연결된 노드 정보 저장 (노드,거리)
  graph[1].append((0,7))
  #노드 2에 연결된 노드 정보 저장 (노드,거리)
  graph[2].append((0,5))
  ```

## DFS 알고리즘

> 특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후 다시 돌아가 다른 경로로 탐색하는 알고리즘

### 동작 과정

1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 1,2번의 과정을 더 이상 수행할 수 없을 때까지 반복

### 예시

- 노드 1을 시작 노드로 설정하여 DFS를 이용해 탐색 진행
  > 인접한 노드 중에서 방문하지 않은 노드가 여러 개 있으면 번호가 낮은 순서부터 처리

1. 시작 노드인 1을 스택에 삽입하고 방문 처리
2. 노드 1에 인접 노드 2,3,8이 있다. 이 중 가장 작은 노드인 2를 스택 삽입
3. 노드 2의 인접 노드 7 스택 삽입
4. 노드 7의 인접 노드 8,6 중 작은 노드인 6 스택 삽입
5. 노드 6의 인접 노드가 없으므로 스택에서 노드 6을 꺼냄
6. 노드 7에서 방문하지 않은 인접 노드 8을 스택에 삽입
7. 노드 8의 인접 노드가 없으므로 노드 8을 스택에서 꺼냄
8. 노드 7의 인접 노드가 없으므로 노드 7을 스택에서 꺼냄
9. 위와 동일 노드 2 꺼냄
10. 노드 1의 인접 노드 3을 스택에 삽입
11. 노드 3의 인접 노드 4,5 중 작은 4를 스택에 삽입
12. 노드 4의 인접노드가 없으므로 노드 4를 스택에서 꺼냄
13. 노드 3의 인접 노드 5를 스택에 삽입
14. 남아 있는 노드에 방문하지 않은 인접 노드가 없다. 따라서 모든 노드를 차래대로 꺼낸다.
    > 결과 : 노드의 탐색 순서(스택에 들어간 순서) <br/>
    > 1 -> 2 -> 7 -> 6 -> 8 -> 3 -> 4 -> 5

### 구현

```Python
#DFS 메서드 정의
def dfs(graph, v, visited):
        # 현재 노드를 방문 처리
        visited[v] = True
        print(v end=' ')
        # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
        for i in graph[v]:
            if not visited[i]:
                dfs(graph, i, visited)
# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
    [],
    [2,3,8],
    [1,7],
    [1,4,5],
    [3,5],
    [3,4],
    [7],
    [2,6,8],
    [1,7]
]
# 각 노드가 방문된 정보를 리스트 자료형으로 표현 (1차원 리스트)
visited = [False] * 9

# 정의된 DFS 함수 호출
dfs(graph, 1, visited)
# 결과
# 1 2 7 6 8 3 4 5
```

<br/><br/>

# BFS Breadth First Search

> 너비 우선 탐색<br/>
> 가까운 노드부터 탐색하는 알고리즘
>
> > 인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 작성하면 자연스럽게 먼저 들어온 것이 먼저 나가게 되어 가까운 노드부터 탐색을 진행하게 된다.

### 동작과정

1. 탐색 시작 노드를 큐에 삽입하고 방문 처리
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리
3. 1,2의 과정을 반복

### 예시

1. 시작 노드인 1을 큐에 삽입하고 방문처리
2. 큐에서 노드 1을 꺼내고 방문하지 않은 인접 노드 2, 3, 8을 모두 큐에 삽입하고 방문 처리
3. 큐에서 노드 2를 꺼내고 방문하지 않은 인접 노드 7을 큐에 삽입하고 방문 처리
4. 큐에서 노드 3을 꺼내고 방문하지 않은 인접 노드 4, 5를 모두 큐에 삽입하고 방문 처리
5. 큐에서 노드 8을 꺼내고 방문하지 않은 인접 노드가 없으므로 무시
6. 큐에서 노드 7을 꺼내고 방문하지 않은 인접 노드 6을 큐에 삽입하고 방문 처리
7. 남아 있는 노드에 방문하지 않은 인접 노드가 없으므로 모든 노드를 차례대로 꺼냄
   > 결과 : 노드의 탐색 순서(큐에 들어간 순서)<br/>
   > 1 -> 2 -> 3 -> 8 -> 7 -> 4 -> 5 -> 6

### 구현

```Python
from collections import deque
# BFS 메서드 정의
def bfs(graph, start, visited):
    # 큐 구현을 위해 deque 라이브러리 사용
    queue = deque([start])
    # 현재 노드를 방문 처리
    visited[start] = True
    # 큐가 빌 때까지 반복
    while queue:
        # 큐에서 하나의 원소를 뽑아 출력
        v = queue.popleft()
        print(v, end=' ')
        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True

# 각 노드가 연결된 정보를 리스트 자료형으로 표현 (2차원 리스트)
graph = [
    [],
    [2,3,8],
    [1,7],
    [1,4,5],
    [3,5],
    [3,4],
    [7],
    [2,6,8],
    [1,7]
]

# 각 ㄴ드가 방문된 정보를 리스트 자료형으로 표현 (1차원 리스트)
visited = [False] * 9

# 정의된 BFS 함수 호출
bfs(graph, 1, visited)

# 결과
# 1 2 3 8 7 4 5 6
```

<br/><br/>

# 정리

|           |      DFS      |              BFS |
| :-------- | :-----------: | ---------------: |
| 동작 원리 |     스택      |               큐 |
| 구현 방법 | 재귀함수 이용 | 큐 자료구조 이용 |
